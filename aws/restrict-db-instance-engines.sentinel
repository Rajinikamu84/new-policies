##### restrict-db-instance-engines.sentinel #####
# This policy uses the Sentinel tfplan import to require that
# all RDS database instances have engines from an allowed list

##### Imports #####

import "tfplan"
import "strings"

##### Functions #####

# Find all resources of a specific type
# from all modules using the tfplan import
find_resources_from_plan = func(type) {

  # Start with an empty map
  resource_maps = {}

  # Iterate over all modules in the tfplan import
  for tfplan.module_paths as path {

    # Append all resources of the specified type
    # or the empty map, {}, if the module does not have any
    # to resource_maps, setting the key to the module path
    resource_maps[path] = tfplan.module(path).resources[type] else {}
  }

  # return resource_maps
  return resource_maps
}

# Get the full address of a resource including modules, type, and name
# in form module.<A>.module.<B>.<type>.<name>
# module_path is like module paths returned by tfplan.module_paths
get_address = func(module_path, type, name) {

  # Handle root and non-root modules differently
  if length(module_path) == 0 {
    # root module
    address = type + "." + name
  } else {
    # non-root module
    address = "module." + strings.join(module_path, ".module.") + "." + type + "." + name
  }

  return address

}

# Validate that all RDS DB instances have engine
# in allowed_engines list
validate_engines = func(allowed_engines) {

  # Initialize validated to true
  # This will be set to false if any DB instances violate rule
  validated = true

  # Set resource_type
  resource_type = "aws_db_instance"

  # Get all resources of specified type
  resource_maps = find_resources_from_plan(resource_type)

  # Loop through the module-level resource maps
  for resource_maps as module_path, resource_map {
    # Loop through the named resources
    for resource_map as name, instances {
      # Loop through resource instances
      for instances as index, r {

        # Get addresses of the resource and the instance
        resource_address = get_address(module_path, resource_type, name)
        instance_address = resource_address + "[" + string(index) + "]"

        # Skip resources that are being destroyed
        # to avoid unnecessary policy violations
        if length(r.diff) == 0 {
          print("Skipping DB instance", instance_address,
            "that is being destroyed.")
          continue
        }

        # Validate that each instance has allowed value
        # If not, print violation message
        if r.applied.engine not in allowed_engines {
          print("RDS DB instance", instance_address,
            "has engine", r.applied.engine,
            "that is not in the allowed list:", allowed_engines)
          validated = false
        }

      } // end resource instances
    } // end named resources
  } // end resorce maps

  # Return validated which will be false if there were any violators
  return validated
}

##### Lists #####
# Allowed RDS DB Engines
allowed_engines = [
  "mysql",
  "oracle-se1",
  "oracle-se2",
  "postgres",
]

##### Rules #####

# Rule to restrict RDS DB engines
engine_allowed = rule {
  validate_engines(allowed_engines)
}

# Main rule that requires other rules to be true
main = rule {
  engine_allowed
}
